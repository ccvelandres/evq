#!/usr/bin/python3
import subprocess
import argparse
import pathlib
import typing
from dataclasses import dataclass
import struct

bin_addr2line = "arm-none-eabi-addr2line"


def decode_hex_string(str, endian="little"):
    value = int.from_bytes(bytes.fromhex(str), byteorder=endian)
    return value


def grab_symbol(exe, addr):
    cmd = "{} -f -e {} 0x{:x}".format(bin_addr2line, exe, addr)
    output = subprocess.check_output(cmd, shell=True)
    return output.decode('utf-8').splitlines()[0]


def get_abs_path(path, alt=None):
    return pathlib.Path(path).absolute() if path is not None else alt

# Regex (([0-9a-z]{2}\s){20})
# Expected record format -- unsigned int should be 4 bytes
# Each record should be 5*4 bytes = 20 bytes
# typedef struct __profile_entry
# {
#     unsigned int is_enter;
#     unsigned int thread_id;
#     unsigned int timestamp;
#     void        *this_fn;
#     void        *call_site;
# } __cyg_profile_entry_t;

@dataclass
class Record:
    struct_fmt = "<IIIII"
    size = struct.calcsize(struct_fmt)
    mask_is_enter = 0x1
    mask_is_vector = 0x2

    def __init__(self, _str, _exe_file) -> None:
        self.struct = struct.unpack(Record.struct_fmt, _str)
        self.is_enter = self.struct[0] & Record.mask_is_enter
        self.is_vector = self.struct[0] & Record.mask_is_vector
        self.thread_id = self.struct[1]
        self.timestamp = self.struct[2]
        self.this_fn = self.struct[3]
        self.call_site = self.struct[4]

        self.s_this_fn = grab_symbol(exe=_exe_file, addr=self.this_fn)
        self.s_call_site = grab_symbol(exe=_exe_file, addr=self.call_site)
        pass

@dataclass
class ThreadContext:
    out_file: typing.IO
    thread_id: int
    call_depth: int
    timestack: typing.List[int]

    def __init__(self, _thread_id, _call_depth=0, _timestack=[]) -> None:
        self.thread_id = _thread_id
        self.call_depth = _call_depth
        self.timestack = _timestack

class SymbolList:
    def __init__(self) -> None:
        self.symbols: typing.Dict[str, typing.List[int]] = {}
        pass

parser = argparse.ArgumentParser()
parser.add_argument("-d", "--data-file", required=False,
                    type=str, help="Path to raw data file")
parser.add_argument("-c", "--capture-file", type=str,
                    help="Path to capture file generated by target")
parser.add_argument("-x", "--exe-file", required=True, type=str,
                    help="Executable file (needs debug info for symbols)")
parser.add_argument("-o", "--out-file",
                    type=str, help="Output file path")
parser.add_argument("-t", "--timebase", default=10,
                    type=int, help="Timestamp units (in us)")
args = parser.parse_args()
print(args)

config = {}
config["exe_file"] = get_abs_path(args.exe_file)
config["capture_file"] = get_abs_path(args.capture_file)
config["data_file"] = get_abs_path(args.data_file, pathlib.Path(
    config["capture_file"]).with_suffix(".data").absolute())
config["out_file"] = get_abs_path(args.out_file, pathlib.Path(
    config["capture_file"]).with_suffix(".out").absolute())
config["timebase"] = args.timebase

print("capture_file_path: {}".format(config["capture_file"]))
print("data_file_path:    {}".format(config["data_file"]))
print("out_file_path:     {}".format(config["out_file"]))
print("exe_file_path:     {}".format(config["exe_file"]))
print("Record byte size:  {}".format(Record.size))


if args.data_file is None:
    start_signature = [0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07]
    end_signature = [0x0F, 0x0E, 0x0D, 0x0C, 0x0B, 0x0A, 0x09, 0x08]
    # Extract actual capture between start and end signature

    with open(config["capture_file"], 'r', encoding='utf-8') as capture_file:
        start = True
        sig_index = 0
        start_pos = 0
        end_pos = 0
        for char in iter(lambda: capture_file.read(3), ''):
            byte = decode_hex_string(char)
            # print(" {:x}:{} {}-{:x}".format(start_signature[sig_index], sig_index,char, byte))

            # Find start and end position for actual capture data
            if start:
                if start_signature[sig_index] == byte:
                    sig_index += 1
                    if sig_index == len(start_signature):
                        start_pos = capture_file.tell() + 1  # +1 for space
                        sig_index = 0
                        start = False
                        print(" start_pos: 0x{:x}".format(start_pos))
                else:
                    sig_index = 0
            else:
                if end_signature[sig_index] == byte:
                    sig_index += 1
                    if sig_index == len(end_signature):
                        end_pos = capture_file.tell() - (len(end_signature) * 3)
                        sig_index = 0
                        print(" end_pos: 0x{:x}".format(end_pos))
                        break
                else:
                    sig_index = 0

        # copy needed data to other file
        capture_file.seek(start_pos-1)
        char_per_line = 3 * Record.size
        with open(config["data_file"], 'wb') as data_file:
            # copy data and format entry per line
            for char in iter(lambda: capture_file.read(char_per_line), ''):
                char = char.replace(" ", "").strip('\r\n\t ')
                data_file.write(bytes.fromhex(char))
                if capture_file.tell() + char_per_line > end_pos:
                    break

thread_contexts: typing.Dict[int, ThreadContext] = {}

with open(config["data_file"], 'rb') as data_file, open(config["out_file"], 'w') as out_file:
    # print header file
    out_file.write("# Executable: {}\n".format(config["exe_file"]))
    out_file.write("# Capture File: {}\n".format(config["capture_file"]))
    out_file.write("# Data File: {}\n".format(config["data_file"]))
    out_file.write("# Timebase: {:d} us\n\n".format(config["timebase"]))

    for record_bytes in iter(lambda: data_file.read(Record.size), ''):
        if len(record_bytes) < Record.size: break
        record = Record(record_bytes, config["exe_file"])

        # create thread context
        if record.thread_id not in thread_contexts:
            thread_contexts[record.thread_id] = ThreadContext(
                record.thread_id, 0, [])

        # increment call stack if enter
        thread_contexts[record.thread_id].call_depth += 1 if record.is_enter else 0

        decode_string = ""
        decode_string += (" " *
                          (thread_contexts[record.thread_id].call_depth * 2))
        if record.is_enter:
            decode_string += ("{ ")
            decode_string += ("0x{:08x}->0x{:08x}  ".format(
                record.call_site, record.this_fn))
            thread_contexts[record.thread_id].timestack.append(
                record.timestamp)
            duration = None
        else:
            decode_string += ("} ")
            decode_string += ("0x{:08x}->0x{:08x}  ".format(
                record.this_fn, record.call_site))
            if len(thread_contexts[record.thread_id].timestack) > 0:
                duration = record.timestamp - \
                    thread_contexts[record.thread_id].timestack.pop()

        decode_string += ("[{:08x}]  ".format(record.thread_id))
        decode_string += ("[{:08d}]  ".format(record.timestamp))
        if record.is_enter:
            decode_string += ("{}->{} ".format(record.s_call_site,
                              record.s_this_fn))
        else:
            decode_string += ("{}->{} ".format(record.s_this_fn,
                              record.s_call_site))

        if duration is not None:
            decode_string += ("[{:08d}]".format(duration))

        decode_string += ("\n")
        out_file.write(decode_string)

        # decrement call stack if exit
        thread_contexts[record.thread_id].call_depth -= 1 if not record.is_enter else 0
